# -*- coding: utf-8 -*-
"""PoseEstimation_2021_0217.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Axk_mOPGJ5gj0WA1Pc5ZBgf0aU8w8VR
"""

import csv
import numpy as np
import pandas
from numpy import array
from numpy import mean
from numpy import std
from numpy import dstack
from pandas import read_csv
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Flatten
from keras.layers import Dropout
from keras.layers import LSTM
from keras.utils import to_categorical
from keras.models import load_model
from keras import backend
from matplotlib import pyplot
import pandas as pd
from sklearn import datasets, linear_model
from sklearn.model_selection import train_test_split
from matplotlib import pyplot as plt
import pandas
from numpy import array

"""# Import Trained Model"""

pretrained_model1 = load_model('TrainedModel/IMUtoLatentFlat.h5')
pretrained_model2 = load_model('TrainedModel/IMUtoLatentUp.h5')
pretrained_model3 = load_model('TrainedModel/IMUtoLatentAcross.h5')
pretrained_model4 = load_model('TrainedModel/IMUtoLatentDown.h5')

# pretrained_model.summary

def get_phase_angle(typeWalk):
    if typeWalk == 1:
        filename = 'TrainedModel/jointAngleMeanFlat.txt'
    elif typeWalk == 2:
        filename = 'TrainedModel/jointAngleMeanUp.txt'
    elif typeWalk == 3:
        filename = 'TrainedModel/jointAngleMeanAcross.txt'
    elif typeWalk == 4:
        filename = 'TrainedModel/jointAngleMeanDown.txt'

    angleRef = pd.read_csv(filename, sep=",", header=None)
    angleRef = angleRef.to_numpy()
    anglePhase = angleRef[:,0]
    angleMean = angleRef[:,1:7]
    return anglePhase, angleMean

def get_mean_std(typeWalk):
    if typeWalk == 1:
        filename = 'TrainedModel/meanFlat.txt'
    elif typeWalk == 2:
        filename = 'TrainedModel/meanUp.txt'
    elif typeWalk == 3:
        filename = 'TrainedModel/meanAcross.txt'
    elif typeWalk == 4:
        filename = 'TrainedModel/meanDown.txt'

    meanAndStd = pd.read_csv(filename, sep=",", header=None)
    meanAndStd = meanAndStd.to_numpy()
    xmean = meanAndStd[0,:]
    xstd = meanAndStd[1,:]
    # print(xmean)
    # print(xstd)
    return xmean, xstd

def calculateAngle(tt, anglePro, angleMean):
    if tt>1:
        tt = 1
    elif tt<0:
        tt = 0
    stateG = np.where(anglePro>=tt)
    tstate = min(stateG[0])

    angleInterp = []
    for j in range(6):
        t1 = anglePro[tstate-1]
        t2 = anglePro[tstate]

        angle1 = angleMean[tstate-1,j];
        angle2 = angleMean[tstate,j];
        anglet = angle1+(angle2-angle1)*(tt-t1)/(t2-t1);
        angleInterp.append(anglet)
    return angleInterp

# FILENAME_TEST="trainData_walkAcross.csv"
# testdata = pandas.read_csv(FILENAME_TEST)
# # print(testdata)
# testdata = testdata.to_numpy()

# testlabel = testdata[:,12:16]
# testAngle = testdata[:,16:22]
# testdata = testdata[:,0:12]

def test_size(size,inputdata,testlabel):
    # tx =[]
    
    # i=0
    # while(i + size) <= len(inputdata) -1 :
    #     tx.append(inputdata[i : i+ size])
        
    #     i += 1
    # return (tx)


    tx =[]
    ty=[]
    
    i=0
    while(i + size) <= len(inputdata) -1 :
        tx.append(inputdata[i : i+ size])
        ty.append(testlabel[i + size])
        
        i += 1
    assert len(tx) == len(ty)
    return (tx,ty)

# DATA_LEN = 10
# txx, tyy = test_size(DATA_LEN,testdata,testlabel)
# print("tx shape: {}".format(np.array(txx).shape))
# print("ty shape: {}".format(np.array(tyy).shape))
# print(DATA_LEN)

def test_model(inputstopoints, pretrained_model):
    get_dense_output=backend.function([pretrained_model.layers[0].input],[pretrained_model.layers[4].output])
    dense_17layer_output=get_dense_output(inputstopoints)
    dense_17layer_output=np.asarray(dense_17layer_output)
    return dense_17layer_output

"""# Activity Detection"""

pretrained_model = load_model('TrainedModel/detectActivity.h5')

# FILENAME_TEST="IMU_walk_20deg_clockwise.csv"
FILENAME_TEST="TrainedModel/Book1.csv"
# FILENAME_TEST="Book1.csv"
testdata = pandas.read_csv(FILENAME_TEST)
print(testdata)
testdata = testdata.to_numpy()
labeldata = testdata[:,12]
testAngle = testdata[:,13:19]
testdata = testdata[:,0:12]

def test_size_x(size,inputdata):
    tx =[]
    
    i=0
    while(i + size) <= len(inputdata) -1 :
        tx.append(inputdata[i : i+ size])
        
        i += 1
    return (tx)

DATA_LEN = 10
tx = test_size_x(DATA_LEN,testdata)
print("tx shape: {}".format(np.array(tx).shape))
print(DATA_LEN)

get_dense_output=backend.function([pretrained_model.layers[0].input],[pretrained_model.layers[3].output])

def test_model_activity(inputstopoints):
    dense_17layer_output=get_dense_output(inputstopoints)
    dense_17layer_output=np.asarray(dense_17layer_output)
    return dense_17layer_output

j = 0
totalResult = []
error_sum = 0
ty_sum = 0
angleErSum = 0
anglePred = []
outputAll = []
while j < len(tx):
    inputstopoints_test=np.expand_dims(tx[j],axis=0)
    # print(inputstopoints_test)
    output_test = test_model_activity(inputstopoints_test)
    output = np.amax(output_test)
    output_idx = np.argmax(output_test)+1
    label = labeldata[j]
    totalResult.append(label == output_idx)
    accuracy = np.sum(totalResult)/len(totalResult)*100
    # print("%d,   %d,    %.5f,   %.5f"%(label, output_idx ,output, accuracy))


    typeWalk = output_idx
    # print(typeWalk)
    xmean, xstd = get_mean_std(typeWalk)
    x = inputstopoints_test - xmean
    x /= xstd

    if typeWalk == 1:
        pretrained_model = pretrained_model1
    elif typeWalk == 2:
        pretrained_model = pretrained_model2
    elif typeWalk == 3:
        pretrained_model = pretrained_model3      
    elif typeWalk == 4:
        pretrained_model = pretrained_model4


    output_test = test_model(x, pretrained_model)
    # print(output_test[0][0])
    outputAll.append(output_test[0][0])
    currentPropagation = output_test[0][0][3]
    # print(currentPropagation)
    anglePhase, angleMean = get_phase_angle(typeWalk)
    # print(anglePhase)
    angleInterp = calculateAngle(currentPropagation, anglePhase, angleMean)
    # print(angleInterp - testAngle[j])
    # print(sum(abs(angleInterp - testAngle[j])))
    anglePred.append(angleInterp)
    angleError = sum(abs(angleInterp - testAngle[j]))/6
    angleErSum += angleError
    angleErMean = angleErSum/j
    print("        %6d,      %6d,      %6d,   %10.5f,       %10.4f,         %10.4f,       %10.4f"%(j, label, output_idx, accuracy, currentPropagation, angleError, angleErMean))

    
    j=j+1

# Current Frame, Real Label,   Pred Label,    Accuracy,     Current Phase,      Current Error,      Total Error

# Current Frame,  Real Label,   Pred Label,    Accuracy,     Current Phase,      Current Error,      Total Error

# print(np.asarray(outputAll))
# print("anglePred shape: {}".format(np.array(outputAll).shape))

print(np.asarray(anglePred))
np.savetxt('TrainedModel/anglePred.txt', np.asarray(anglePred), delimiter=',')
np.savetxt('TrainedModel/outputAll.txt', np.asarray(outputAll), delimiter=',')

# j = 0
# totalResult = []
# error_sum = 0
# ty_sum = 0
# angleErSum = 0
# while j < len(txx):
#     inputstopoints=np.expand_dims(txx[j],axis=0)

#     x = inputstopoints - xmean
#     x /= xstd

#     output_test = test_model(x, pretrained_model3)
#     # print(output_test)
#     # predicted = model.predict(inputstopoints)
#     # print(predicted)
#     # print(Y_Test[j])

#     totalResult.append(output_test[0])
#     error_test = output_test[0] - tyy[j]
#     # print(output_test[0][0])
#     error_current = np.sum(abs(error_test))
#     # print(error_current)
#     ty_current = np.sum(abs(tyy[j]))
#     error_sum += error_current
#     ty_sum += ty_current

#     currentPropagation = output_test[0][0][3]
#     angleInterp = calculateAngle(currentPropagation, anglePro, angleMean)
#     # print(angleInterp)
#     # print(testAngle[j])
#     angleError = sum(angleInterp - testAngle[j])/6
#     angleErSum += abs(angleError)
#     angleErMean = angleErSum/j
#     # print(angleError)
#     # print("%10.5f   %10.4f   %10.4f"%(error_test[0,3], output_test[0][0][3], error_sum/ty_sum*100))
#     print("%10.5f   %10.4f   %10.4f   %10.4f"%(error_test[0,3], output_test[0][0][3], angleError, angleErMean))
#     j=j+1

# typlot = np.array(tyy)
# totalResultplot = np.array(totalResult)
# fig = plt.figure()
# ax = fig.add_subplot(111)
# ax.plot(typlot[:,0],label="Real")
# ax.legend(loc='upper left')
# plt.plot(totalResultplot[:,:,0],label="Prediction")
# plt.legend(loc='upper left')
# plt.show()
